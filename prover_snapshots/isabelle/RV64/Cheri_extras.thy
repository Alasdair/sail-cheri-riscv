chapter \<open>Generated by Lem from \<open>handwritten_support/cheri_extras.lem\<close>.\<close>

theory "Cheri_extras" 

imports
  Main
  "LEM.Lem_pervasives"
  "LEM.Lem_pervasives_extra"
  "Sail.Sail2_instr_kinds"
  "Sail.Sail2_values"
  "Sail.Sail2_operators_mwords"
  "Sail.Sail2_prompt_monad"
  "Sail.Sail2_prompt"

begin 

\<comment> \<open>\<open>open import Pervasives\<close>\<close>
\<comment> \<open>\<open>open import Pervasives_extra\<close>\<close>
\<comment> \<open>\<open>open import Sail2_instr_kinds\<close>\<close>
\<comment> \<open>\<open>open import Sail2_values\<close>\<close>
\<comment> \<open>\<open>open import Sail2_operators_mwords\<close>\<close>
\<comment> \<open>\<open>open import Sail2_prompt_monad\<close>\<close>
\<comment> \<open>\<open>open import Sail2_prompt\<close>\<close>

\<comment> \<open>\<open>val write_ram : forall 'rv 'e 'n. Size 'n => write_kind -> mword ty64 -> integer -> mword 'n -> bool -> monad 'rv bool 'e\<close>\<close>
definition write_ram  :: \<open> write_kind \<Rightarrow>(64)Word.word \<Rightarrow> int \<Rightarrow>('n::len)Word.word \<Rightarrow> bool \<Rightarrow>('rv,(bool),'e)monad \<close>  where 
     \<open> write_ram wk addr width data tag = (
  write_memt instance_Sail2_values_Bitvector_Machine_word_mword_dict instance_Sail2_values_Bitvector_Machine_word_mword_dict wk addr width data (bitU_of_bool tag))\<close> 
  for  wk  :: " write_kind " 
  and  addr  :: "(64)Word.word " 
  and  width  :: " int " 
  and  data  :: "('n::len)Word.word " 
  and  tag  :: " bool "


\<comment> \<open>\<open>val read_ram : forall 'rv 'e 'n. Size 'n => read_kind -> mword ty64 -> integer -> bool -> monad 'rv (mword 'n * bool) 'e\<close>\<close>
definition read_ram  :: \<open> read_kind \<Rightarrow>(64)Word.word \<Rightarrow> int \<Rightarrow> bool \<Rightarrow>('rv,(('n::len)Word.word*bool),'e)monad \<close>  where 
     \<open> read_ram rk addr width read_tag = (
  if read_tag then
    read_memt instance_Sail2_values_Bitvector_Machine_word_mword_dict instance_Sail2_values_Bitvector_Machine_word_mword_dict rk addr width \<bind> ( (\<lambda>x .  
  (case  x of
      ((data :: ( 'n::len) Word.word), (tag :: bitU)) =>
  bool_of_bitU_fail tag \<bind>
    ((\<lambda> (tag :: bool) .  return (data, tag)))
  )))
  else
    read_mem instance_Sail2_values_Bitvector_Machine_word_mword_dict instance_Sail2_values_Bitvector_Machine_word_mword_dict rk ()  addr width \<bind> ((\<lambda> (data :: ( 'n::len)Word.word) . 
    return (data, False))))\<close> 
  for  rk  :: " read_kind " 
  and  addr  :: "(64)Word.word " 
  and  width  :: " int " 
  and  read_tag  :: " bool "


\<comment> \<open>\<open>val write_tag_bool : forall 'rv 'e. mword ty64 -> bool -> monad 'rv unit 'e\<close>\<close>
definition write_tag_bool  :: \<open>(64)Word.word \<Rightarrow> bool \<Rightarrow>('rv,(unit),'e)monad \<close>  where 
     \<open> write_tag_bool addr tag = (
  read_memt instance_Sail2_values_Bitvector_Machine_word_mword_dict instance_Sail2_values_Bitvector_Machine_word_mword_dict Read_plain addr(( 16 :: int)) \<bind> ( (\<lambda>x .  
  (case  x of
      ((cap :: 128 Word.word), _) =>
  write_memt instance_Sail2_values_Bitvector_Machine_word_mword_dict
    instance_Sail2_values_Bitvector_Machine_word_mword_dict Write_plain 
  addr (( 16 :: int)) cap (bitU_of_bool tag) \<bind>
    ( (\<lambda>x .  (case  x of _ => return ()  )))
  ))))\<close> 
  for  addr  :: "(64)Word.word " 
  and  tag  :: " bool "


\<comment> \<open>\<open>val read_tag_bool : forall 'rv 'e. mword ty64 -> monad 'rv bool 'e\<close>\<close>
definition read_tag_bool  :: \<open>(64)Word.word \<Rightarrow>('rv,(bool),'e)monad \<close>  where 
     \<open> read_tag_bool addr = (
  read_memt instance_Sail2_values_Bitvector_Machine_word_mword_dict instance_Sail2_values_Bitvector_Machine_word_mword_dict Read_plain addr(( 16 :: int)) \<bind> ( (\<lambda>x .  
  (case  x of ((cap :: 128 Word.word), tag) => bool_of_bitU_fail tag ))))\<close> 
  for  addr  :: "(64)Word.word "

end
